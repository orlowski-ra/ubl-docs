<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UBL 2.1 Invoice Structure Viewer</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --primary-color: #0056b3;
            --bg-color: #f4f6f8;
            --border-color: #d1d5db;
            --text-color: #333;
            --sidebar-width: 450px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background-color: #fff;
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
        }

        header h1 {
            margin: 0;
            font-size: 1.2rem;
            color: var(--primary-color);
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Tree Sidebar */
        .tree-sidebar {
            width: var(--sidebar-width);
            background: #fff;
            border-right: 1px solid var(--border-color);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .search-box {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            background: #f9fafb;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .search-box input {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }

        .tree-content {
            padding: 10px;
        }

        /* Tree Node Styles */
        .tree-node {
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .node-header {
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            white-space: nowrap;
        }

        .node-header:hover {
            background-color: #eef2ff;
        }

        .node-header.active {
            background-color: #e0e7ff;
            font-weight: 500;
        }

        .toggle-icon {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            font-family: monospace;
            color: #6b7280;
        }

        .node-icon {
            margin-right: 6px;
            font-size: 0.8em;
            width: 16px;
            text-align: center;
            border-radius: 2px;
            font-weight: bold;
        }

        .icon-cac { color: #d97706; background: #fef3c7; border: 1px solid #fcd34d; } /* Aggregate */
        .icon-cbc { color: #059669; background: #d1fae5; border: 1px solid #6ee7b7; } /* Basic */

        .node-name {
            color: var(--text-color);
        }

        .node-cardinality {
            margin-left: auto;
            font-size: 0.75em;
            color: #6b7280;
            background: #f3f4f6;
            padding: 1px 4px;
            border-radius: 4px;
        }

        .children-container {
            margin-left: 18px;
            border-left: 1px solid #e5e7eb;
        }

        /* Details Panel */
        .details-panel {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
            background-color: #fff;
        }

        .detail-card {
            max-width: 800px;
            margin: 0 auto;
        }

        .detail-header {
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .detail-title {
            font-size: 1.5rem;
            color: var(--primary-color);
            margin: 0 0 5px 0;
        }

        .detail-path {
            font-family: monospace;
            color: #6b7280;
            font-size: 0.9em;
            background: #f3f4f6;
            padding: 4px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .info-grid {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        .label {
            font-weight: 600;
            color: #4b5563;
        }

        .value {
            color: #111827;
        }

        .description-box {
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 15px;
            border-radius: 6px;
            line-height: 1.6;
        }

        .enum-list {
            margin: 0;
            padding-left: 20px;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255,255,255,0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 15px;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .error-message {
            color: #dc2626;
            text-align: center;
            max-width: 500px;
        }
    </style>
</head>
<body>
    <div id="app">
        <div v-if="loading" class="loading-overlay">
            <div class="spinner"></div>
            <p>{{ loadingStatus }}</p>
        </div>

        <div v-if="error" class="loading-overlay">
            <div class="error-message">
                <h3>Error Loading Schema</h3>
                <p>{{ error }}</p>
                <button @click="loadSchema" style="margin-top:10px; padding: 8px 16px; cursor:pointer;">Retry</button>
            </div>
        </div>

        <header>
            <h1>UBL 2.1 Structure Viewer (Invoice)</h1>
            <div style="font-size: 0.8rem; color: #666;">
                Based on OASIS UBL 2.1 Standard
            </div>
        </header>

        <div class="container" v-if="rootNode">
            <div class="tree-sidebar">
                <div class="search-box">
                    <input type="text" v-model="searchQuery" placeholder="Search elements..." @input="handleSearch">
                </div>
                <div class="tree-content">
                    <tree-node 
                        :node="rootNode" 
                        :selected-id="selectedNodeId"
                        :depth="0"
                        :search-query="searchQuery"
                        @select="selectNode"
                        @toggle="toggleNode">
                    </tree-node>
                </div>
            </div>

            <div class="details-panel">
                <div v-if="selectedNode" class="detail-card">
                    <div class="detail-header">
                        <h2 class="detail-title">{{ selectedNode.name }}</h2>
                        <div class="detail-path">{{ selectedNode.path }}</div>
                    </div>

                    <div class="info-grid">
                        <div class="label">Cardinality</div>
                        <div class="value">
                            <span :style="{color: selectedNode.required ? '#dc2626' : '#059669', fontWeight: 'bold'}">
                                {{ selectedNode.min }}..{{ selectedNode.max === -1 ? 'n' : selectedNode.max }}
                            </span>
                            <span v-if="selectedNode.required"> (Mandatory)</span>
                            <span v-else> (Optional)</span>
                        </div>

                        <div class="label">Type</div>
                        <div class="value">{{ selectedNode.type || 'Aggregate' }}</div>

                        <div class="label">Namespace</div>
                        <div class="value">{{ selectedNode.namespace }}</div>

                        <div class="label">Description</div>
                        <div class="value description-box">{{ selectedNode.description || 'No description available.' }}</div>

                        <div class="label" v-if="selectedNode.enums && selectedNode.enums.length">Allowed Values</div>
                        <div class="value" v-if="selectedNode.enums && selectedNode.enums.length">
                            <ul class="enum-list">
                                <li v-for="val in selectedNode.enums" :key="val">{{ val }}</li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div v-else style="color: #999; text-align: center; margin-top: 50px;">
                    Select an element from the tree to view details.
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, reactive } = Vue;

        // Recursive Tree Component
        const TreeNode = {
            name: 'TreeNode',
            props: ['node', 'selectedId', 'depth', 'searchQuery'],
            emits: ['select', 'toggle'],
            template: `
                <div class="tree-node" v-show="node.visible !== false">
                    <div 
                        class="node-header" 
                        :class="{ active: selectedId === node.id }"
                        :style="{ paddingLeft: (depth * 10) + 'px' }"
                        @click="$emit('select', node)"
                    >
                        <span 
                            class="toggle-icon" 
                            @click.stop="$emit('toggle', node)"
                        >
                            {{ node.children && node.children.length ? (node.expanded ? '▼' : '▶') : '' }}
                        </span>
                        
                        <span class="node-icon" :class="node.isAggregate ? 'icon-cac' : 'icon-cbc'">
                            {{ node.isAggregate ? 'A' : 'E' }}
                        </span>

                        <span class="node-name">{{ node.name }}</span>
                        
                        <span class="node-cardinality">
                            {{ node.min }}..{{ node.max === -1 ? 'n' : node.max }}
                        </span>
                    </div>

                    <div v-if="node.expanded && node.children" class="children-container">
                        <tree-node 
                            v-for="child in node.children" 
                            :key="child.id"
                            :node="child"
                            :selected-id="selectedId"
                            :depth="depth + 1"
                            :search-query="searchQuery"
                            @select="$emit('select', $event)"
                            @toggle="$emit('toggle', $event)"
                        ></tree-node>
                    </div>
                </div>
            `
        };

        createApp({
            components: { TreeNode },
            setup() {
                const loading = ref(true);
                const loadingStatus = ref('Initializing...');
                const error = ref(null);
                const rootNode = ref(null);
                const selectedNode = ref(null);
                const selectedNodeId = ref(null);
                const searchQuery = ref('');

                // CDN URLs for UBL 2.1 JSON Schema (via Tradeshift Repo)
                const BASE_URL = 'https://cdn.jsdelivr.net/gh/Tradeshift/tradeshift-ubl-jsonschema@master/src/main/resources/org/oasis-open/ubl/schemas/';
                const MAIN_DOC_URL = BASE_URL + 'maindoc/UBL-Invoice-2.1.json';

                // Cache for fetched schemas
                const schemaCache = new Map();

                const fetchSchema = async (url) => {
                    if (schemaCache.has(url)) return schemaCache.get(url);
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(`Failed to fetch ${url}`);
                    const json = await res.json();
                    schemaCache.set(url, json);
                    return json;
                };

                const resolveRef = async (ref, contextUrl) => {
                    // Ref format: "../common/UBL-CommonBasicComponents-2.1.json#/definitions/UBLVersionID"
                    const [filePart, defPart] = ref.split('#');
                    
                    // Resolve file URL relative to contextUrl
                    const currentDir = contextUrl.substring(0, contextUrl.lastIndexOf('/') + 1);
                    // Simple relative path resolution
                    const targetUrl = new URL(filePart, currentDir).href;
                    
                    const schema = await fetchSchema(targetUrl);
                    
                    // Navigate to definition
                    const path = defPart.replace('/definitions/', '');
                    if (schema.definitions && schema.definitions[path]) {
                        return { schema: schema.definitions[path], url: targetUrl };
                    }
                    throw new Error(`Definition ${path} not found in ${targetUrl}`);
                };

                // Build tree recursively
                const buildTree = async (schemaNode, name, path, contextUrl, isRoot = false) => {
                    const node = {
                        id: path,
                        name: name,
                        path: path,
                        description: schemaNode.description || '',
                        min: schemaNode.minItems || 0,
                        max: schemaNode.maxItems || -1, // -1 means unbounded
                        required: (schemaNode.minItems || 0) > 0,
                        expanded: isRoot,
                        visible: true,
                        children: [],
                        isAggregate: false,
                        type: '',
                        enums: [],
                        namespace: ''
                    };

                    // Handle $ref (The item definition)
                    let definition = schemaNode;
                    let definitionUrl = contextUrl;

                    if (schemaNode.items && schemaNode.items.$ref) {
                        const resolved = await resolveRef(schemaNode.items.$ref, contextUrl);
                        definition = resolved.schema;
                        definitionUrl = resolved.url;
                    }

                    node.description = definition.description || node.description;
                    node.title = definition.title;
                    
                    // Determine Type
                    if (definition.type === 'object' || definition.properties) {
                        node.isAggregate = true;
                        node.type = 'Aggregate';
                    } else if (definition.type === 'string' || definition.type === 'number' || definition.type === 'boolean') {
                        node.type = definition.type;
                    } else if (definition.base) {
                         node.type = definition.base; // Sometimes used in UBL schemas
                    }

                    // Extract Namespace from URL (crude heuristic)
                    if (definitionUrl.includes('CommonAggregateComponents')) node.namespace = 'cac';
                    else if (definitionUrl.includes('CommonBasicComponents')) node.namespace = 'cbc';
                    else if (definitionUrl.includes('Invoice')) node.namespace = 'inv';
                    else node.namespace = 'ubl';

                    // Extract Enums
                    if (definition.enum) {
                        node.enums = definition.enum;
                    }

                    // Recursively process properties if Aggregate
                    if (node.isAggregate && definition.properties) {
                        // For performance, we might want to load children on expand, but for this size, pre-loading is okayish?
                        // Actually UBL is huge. We MUST be careful. 
                        // However, the JSON schema structure is essentially tree-like. 
                        // Circular refs are possible in UBL (e.g. Party -> .. -> Party).
                        // To prevent infinite loops, check depth or path repetition.
                        
                        // Limit depth to prevent infinite recursion on circular types (common in UBL)
                        // Or check if we are already in a node of this type in the ancestry.
                        const pathParts = path.split('/');
                        const depth = pathParts.length;
                        // 15 is a safe generic depth limit for UBL Invoice
                        if (depth < 15) { 
                             const props = Object.entries(definition.properties);
                             for (const [propName, propSchema] of props) {
                                // Skip internal fields if any
                                if (propName.startsWith('_')) continue; 
                                
                                // To avoid freezing UI, we might need to use requestAnimationFrame or chunking if it was massive,
                                // but we will do a simplified non-blocking recursive build for the root's immediate children,
                                // and maybe lazy load deeper? 
                                // For this implementation, let's try building 2 levels deep, then lazy load?
                                // "1:1 Peppol" loads everything. Let's try to load fully but handle circular refs.
                                
                                // Circular Ref Check: If the current property name appeared recently in parents
                                // UBL is mostly hierarchical.
                                
                                const childNode = await buildTree(propSchema, propName, `${path}/${propName}`, definitionUrl);
                                node.children.push(childNode);
                             }
                        }
                    }

                    return node;
                };
                
                // We need a specific builder for the Root Invoice
                const loadSchema = async () => {
                    loading.value = true;
                    error.value = null;
                    try {
                        loadingStatus.value = 'Fetching Invoice Schema...';
                        const mainSchema = await fetchSchema(MAIN_DOC_URL);
                        
                        loadingStatus.value = 'Building Tree Structure...';
                        
                        // Transform the flat properties of Invoice into our Node structure
                        const root = {
                            id: 'Invoice',
                            name: 'Invoice',
                            path: '/Invoice',
                            description: mainSchema.description || 'A document used to request payment.',
                            min: 1,
                            max: 1,
                            required: true,
                            expanded: true,
                            visible: true,
                            children: [],
                            isAggregate: true,
                            type: 'Document',
                            namespace: 'inv'
                        };

                        const props = Object.entries(mainSchema.properties);
                        // Process concurrently
                        const childrenPromises = props.map(async ([key, schema]) => {
                             // Skip metadata fields like UBLExtensions for clarity if desired, keeping for 1:1
                             return await buildTree(schema, key, `/Invoice/${key}`, MAIN_DOC_URL);
                        });

                        root.children = await Promise.all(childrenPromises);
                        
                        // Sort children: CBC first (Elements), then CAC (Aggregates) usually looks better, or alphabetical.
                        // Peppol standard order is usually schema order. We keep schema order.
                        
                        rootNode.value = root;
                        selectNode(root);

                    } catch (e) {
                        console.error(e);
                        error.value = e.message + ". \nCheck your internet connection or if the CDN is reachable.";
                    } finally {
                        loading.value = false;
                    }
                };

                const selectNode = (node) => {
                    selectedNode.value = node;
                    selectedNodeId.value = node.id;
                };

                const toggleNode = (node) => {
                    node.expanded = !node.expanded;
                };

                const handleSearch = () => {
                    if (!rootNode.value) return;
                    const q = searchQuery.value.toLowerCase();
                    
                    const filterRecursive = (node) => {
                        const nameMatch = node.name.toLowerCase().includes(q);
                        const pathMatch = node.path.toLowerCase().includes(q);
                        let childMatch = false;

                        if (node.children) {
                            node.children.forEach(child => {
                                const cMatch = filterRecursive(child);
                                if (cMatch) childMatch = true;
                            });
                        }

                        // If search is empty, show everything (collapsed state maintained logic can be complex, simply expand all if searching)
                        if (!q) {
                            node.visible = true;
                            return true;
                        }

                        const match = nameMatch || pathMatch || childMatch;
                        node.visible = match;
                        if (match && childMatch) node.expanded = true; // Expand if children match
                        return match;
                    };

                    filterRecursive(rootNode.value);
                };

                // Init
                loadSchema();

                return {
                    loading,
                    loadingStatus,
                    error,
                    rootNode,
                    selectedNode,
                    selectedNodeId,
                    searchQuery,
                    selectNode,
                    toggleNode,
                    handleSearch,
                    loadSchema
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
